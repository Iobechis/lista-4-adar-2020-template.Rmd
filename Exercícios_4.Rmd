---
title: "Lista de Exercícios 4 - ADAR"
author: "Ignazio Bechis"
date: "01/02/2021"
output: html_document
---

---
title: "Lista de Exercícios 4 - ADAR/UFSM"
author: "Nome d@ alun@"
date: "2021-01-22"
output: html_document
---

<!-- 
Lista 4 original foi dividida em duas:
uma com exercícios tidyr e outra com dplyr
-->





## Pré-requisitos

**Pacotes necessários**
library(tidyverse)

library(easypackages)

pacotes <- c(
  "openair",
  "lubridate",
  "scales",
  "rio",
  "readr",
  "dplyr",
  "hablar",
  "stringr"
)

libraries(pacotes)

library(stringr)

**Dados**

arq_temp <- tempfile(fileext = ".RData")
download.file(
  "https://github.com/lhmet/adar-ufsm/blob/master/data/dados-lista-exerc4-cap9.RData?raw=true",
  destfile = arq_temp,
  mode = "wb"
)
# nome dos dados carregados para os exercícios
print(load(arq_temp))


## Exercícios

1. Converta os dados de anomalias padronizadas do índice de oscilação sul armazenados no *quadro de dados* `soi` (mostrado abaixo) para o formato \"arrumado\" e em ordem cronológica. Os nomes das variáveis na tabela de dados arrumado deve estar sempre em letras minúsculas (conheça a função `tolower()`).
```{r}

q1 <- as_tibble(soi) %>%
  pivot_longer(
    .,
    cols = -(YEAR),
    names_to = "mes",
    values_to = "soi"
  )  %>%
  rename(.,"year" = YEAR
  )

q1 <- q1 %>% mutate_if(is.character, as.integer)
glimpse(q1)

```
- - -

2. Faça a conversão dos dados de precipitação diária, armazenados em um **`tibble**`, para o \"formato arrumado\" e transforme as datas para o tipo de dados *date*.
A estrutura esperada do **`tibble`** resultante é mostrada abaixo:
```
```{r}
q2 <- as_tibble(precd_ncdf)

head(q2, n = 5)

q2_prec <- pivot_longer(
  data = q2,
  cols = c(3:10),
  names_to = "date",
  values_to = "prec"
)

q2_prec$date <- gsub("X", "", q2_prec$date)


glimpse(q2_prec)

```
- - -
3. Coloque os dados de poluição (**`tibble`** `poluentes`) no formato \"arrumado\".

```{r}
q3 <- as_tibble(poluentes)
glimpse(q3)
```
- - -
4. 

a. Coloque os dados meteorológicos diários da estação meteorológica de Santa Maria no formato arrumado. 
```{r}
str(dados_sm)

q4 <- as_tibble(dados_sm)

q4_dados <- pivot_longer(data = q4,
  cols = c(1:4), names_to = "day",
  values_to = "value")

glimpse(q4_dados)

q4_dados_final <- pivot_wider(
  data = q4_dados,
  names_from = element,
  values_from = value
)

glimpse(q4_dados_final)




```

```
   b. Deixe os dados ordenados cronologicamente e obtenha as variáveis com nomes e ordem conforme mostrado na estrutura de dados esperada.
```{r}
q4_dados_final %>% select(id, year, everything())

q4_dados_final$day <- str_replace(q4_dados_final$day, pattern = "[d]", replacement = "") 

q4_dados_final$day <- as.integer(q4_dados_final$day)

glimpse(q4_dados_final)
```
   c. Acrescente uma nova variável `tmed` aos dados de temperatura diária arrumados, obtida da média diária da `tmax` e `tmin`.
```{r}
q4_media <- mutate(q4_dados_final, tmed = (tmax + tmin)/2)

glimpse(q4_media)
```

- - -
5. Com os dados obtidos na questão 4c: 
   a. renomeie as as colunas `year`, `month` e `day`para `ano`, `mes` e `dia`, respectivamente.
```{r}
q5 <- q4_dados_final %>%
  rename(
    .,
    "ano" = year,
    "mes" = month,
    "dia" = day)
(q5 %>% head(n =3))


```
   b. junte as colunas `ano`, `mes` e `dia` em uma única coluna denominada `data` de forma que a classe dessa nova váriavel seja `date`.
```{r}
q5b <- unite(
  data = q5,
  col = data,
  ano, mes, dia,
  sep = "-"
)

```   
   
   c. Filtre os dados obtidos em **(b)** de forma a descobrir as datas em que as observações de `tmax` ou `tmin` são faltantes. Mostre o **`tibble`** filtrado com as datas e explique o porquê de seus valores. *DICA: quantas observações são esperadas por ano?*. 
```{r}
q5b$data <- as.Date(q5b$data)

glimpse(q5b)
```
6. A amostra de dados abaixo possui medidas a cada 6 horas de uma estação meteorológica de superfície. Reestruture os dados no formato \"arrumado\" e junte as informações de data e horário em uma única variável da classe *POSIXct* denominada `date`.
```{r}


q6 <- as_tibble(dados_zorra)
(q6)

q6<- pivot_longer(
  data = q6,
  cols = c(2:9),
  names_to = "temp.h",
  values_to = "value"
)

q6_tab <- separate(
  data = q6,
  col = temp.h,
  sep = ".",
  into = c("tmax", "tmin", "hora"))

```
- - -
7. Faça uma junção da tabela de dados de informações das estações de poluição (`estacoes`, dada abaixo) com os períodos de duração de poluição crítica (`poluentes`). A tabela resultante deve conter somente estações que tenham coordenadas espaciais e medidas de poluentes válidas.
Estrutura da tabela resultante:
```{r}  


estacoes_tb <- as_tibble(estacoes)

poluentes_tb <- as_tibble(poluentes)

poluente_novo = poluentes %>%
  rename(., "id" = estacao) %>% 
  select(id, everything())
  
glimpse(poluente_novo)


estacoes_poluentes <- inner_join(
  x = estacoes_tb, 
  y = poluente_novo,
  by = "id"
)
glimpse(estacoes_poluentes)
```
- - -
8. Combine as 2 tabelas abaixo de forma que:
  a. A tabela resultante contenha todas as datas compreendidas pelas duas tabelas (e em ordem cronológica) e as observações de umidade do solo (`theta`) sejam preenchidas com `NA`. 
```{r}
datas_comp_tb <- as_tibble(datas_comp)

datas_obs_tb <- as_tibble(datas_obs)

datas_merj <- full_join(
  x = datas_comp_tb, 
  y = datas_obs_tb,
  by = "date")
datas_merj <- datas_merj[order(as.Date(datas_merj$date, format="%Y-%m/%d")),]
glimpse(datas_merj)

```  
  b. a tabela resultante contenha exatamente as datas da tabela `data_comp` (em ordem cronológica) e as observações de umidade do solo (`theta`) sejam preenchidas com `NA`.
```{r}
datas_merj_left <- left_join(
  x = datas_comp_tb, 
  y = datas_obs_tb,
  by = "date")

  glimpse(datas_merj_left)


```  
- - - 
9. Utilizando os dados horários de estações meteorológicas automáticas (EMA) do RS (`dados_rs_08_16`), determine a data inicial, final e o período de dados (em anos) de cada estação (identificada pela variável `site`).

```{r}
data_inicial <- dados_rs_08_16[1,]
data_final <- dados_rs_08_16 %>%
  slice(
    .,
    n()
    )
data_final
```

- - -
10. Determine a porcentagem de dados válidos (ou seja, não faltantes) de cada variável para cada EMA. Aproxime os valores para números inteiros.
```{r}
dados <- dados_rs_08_16

n_obs <- dados %>% count(site)

dados_tair <- dados %>%
  group_by(site) %>%
  filter(!is.na(tair)) %>%
  summarise(., tair = n()) %>%
  mutate(., tair = (tair * 100) / n_obs$n)

dados_rh <- dados %>%
  group_by(site) %>%filter(!is.na(rh)) %>%
  summarise(., rh = n()) %>%
  mutate(., rh = (rh * 100) / n_obs$n)

dados_prec <- dados %>%
  group_by(site) %>%filter(!is.na(prec))%>%
  summarise(., prec = n()) %>%
  mutate(., prec = (prec * 100) / n_obs$n)

dados_rg <- dados %>%
  group_by(site) %>%filter(!is.na(rg)) %>%
  summarise(., rg = n()) %>%
  mutate(., rg = (rg * 100) / n_obs$n)

dados_ws <- dados %>%
  group_by(site) %>%filter(!is.na(ws)) %>%
  summarise(., ws = n()) %>%
  mutate(., ws = (ws * 100) / n_obs$n)

dados_validos <- full_join(dados_tair,
                               dados_rh,
                               by = "site") %>%
  full_join(dados_prec,
            by = "site") %>%
  full_join(dados_rg,
            by = "site") %>%
  full_join(dados_ws,
            by = "site")

dados_validos[2:6] <- dados_validos %>%
  select(
    .,
    tair:ws) %>%
  mutate_if(
    is.double,
    as.integer)

glimpse(dados_validos)

```
- - -
11. Com o resultado da questão anterior, adicione uma variável indicativa da porcentagem média de observações válidas de todas variáveis. Ordene esta tabela em ordem decrescente da disponibilidade média de observações. 
```{r}
med_dados_validos <- dados_validos %>%
  gather(., "variaveis", "porcentagens", -site) %>%
  mutate(porcentagens = as.numeric(porcentagens)) %>%
  group_by(site) %>%
  mutate(disp_med = mean(porcentagens)) %>%
  ungroup() %>%
  spread(variaveis, porcentagens) %>%
  select(site, tair, rh, prec, rg, ws, disp_med) %>%
  arrange(., desc(disp_med))

glimpse(med_dados_validos)
```  
- - -
12. Para a EMA de Santa Maria (ver `info_emas_rs_08_16`) obtenha o ciclo diurno médio da temperatura do ar e a porcentagem de dados válidos usados para compor a `tair` média de cada hora. 
```{r}
dados_temp <- full_join(
  info_emas_rs_08_16,
  dados_rs_08_16,
  by = "site") %>%
  select(
    .,site,name,
    date, tair) %>%
  rename(.,"hour" = date)

dados_temp$hour <- lubridate::hour(dados_temp$hour)

dados_sm <- dados_temp %>%
  filter(site == "A803")

total_obs <- pull(dados_sm %>% count(hour))
tmed_sm <- dados_sm %>%
  filter(!is.na(tair)) %>%
  group_by(hour) %>%
  summarise(
    .,
    tair_med = mean(tair),
    obs_val = n() / total_obs[1]
    )

glimpse(tmed_sm)

```

> Dica: Para extrair as horas das datas use a função `lubridate::hour(date)`.

- - -
13. Com os dados de temperatura do ar (`tair`) filtrados para EMA de Santa Maria (a) selecione somente os dias observações válidas nas 24 horas (dias completos, ou seja, sem nenhuma falha nas 24 h). A partir destes dados
```{r}
dados_h_sm <- full_join(
  info_emas_rs_08_16,
  dados_rs_08_16,
  by = "site") %>%
  select(.,site,
  name,date,tair) %>%
  filter(site == "A803")

info_sm <- dados_h_sm %>%
  rename(.,"dia" = date) 

info_sm$dia <- lubridate::floor_date(info_sm$dia, unit = "day")

datas_completas <- info_sm %>%
  group_by(dia) %>%
  filter(!is.na(tair)) %>%
  summarise(dias = (length(dia) == 24)) %>%filter(dias == TRUE) %>%
  select(.,dia)

nrow(info_sm)
glimpse(datas_completas)
glimpse(tail(datas_completas))
```
(b) obtenha a frequência de ocorrência da temperatura mínima para cada horário do dia. 
```{r}
  primeira_mod <- dados_h_sm %>%
    separate(.,col = date,
    sep = " ",into = c("date", "hour"))

temp_min <- primeira_mod %>%
  group_by(date) %>%
  filter(!is.na(tair)) %>%
  mutate(
    completos = (length(hour) == 24)
    ) %>%
  filter(completos == TRUE) %>%
  select(.,date:tair) %>%slice(.,which.min(tair))
temp_min$hour <- as.difftime(
  temp_min$hour,units = "hours") %>%
  gsub(pattern = " hours",replacement = "")

freq_htmin <- temp_min %>%
  arrange(hour) %>%
  group_by(hour) %>%
  summarise(.,n = n()) %>%
rename(.,"h_tmin" = hour)

freq_htmin$h_tmin <- as.integer(freq_htmin$h_tmin)

glimpse(freq_htmin)
```
(c) Apresente a tabela de resultados em ordem decrescente da frequência de ocorrência.
> Dica: para obter o dia a partir da data e hora (coluna `date` do tipo `POSIXct`) use `lubridate::floor_date(date, unit = "day")`.
```{r}

freq_htmin <- freq_htmin %>% arrange(., desc(n))

glimpse(freq_htmin)
```
- - -
14. Neste exercício aplicaremos um controle de qualidade básico de dados meteorológicos. Você irá verificar se nos dados da EMA de Santa Maria (A803, mesmos dados do item **a** do exercício anterior) ocorreram casos em que a temperatura máxima (mínima) diária foi acima (abaixo) dos recordes históricos registrados pela estação meteorológica convencional do INMET de Santa Maria (site 83936). Os recordes históricos de temperatura máxima e mínima estão disponíveis nos dados `recordes_temp` para cada mês do ano. Você deve obter os casos suspeitos na estrutura conforme abaixo.
```
# A tibble: 8 x 7
  date                 tmax  tmin   mes site 
  <dttm>              <dbl> <dbl> <dbl> <chr>
1 2009-10-30 00:00:00  35.8  20.4    10 83936
2 2009-10-31 00:00:00  36.8  21.8    10 83936
3 2013-12-26 00:00:00  38.3  21.2    12 83936
4 2014-02-05 00:00:00  38    23.8     2 83936
5 2014-02-06 00:00:00  38.3  24.4     2 83936
6 2014-02-07 00:00:00  39.5  23.2     2 83936
7 2014-02-09 00:00:00  38.3  22.9     2 83936
8 2014-10-29 00:00:00  36.8  22.4    10 83936
# ... with 2 more variables: tmin_abs <dbl>,
#   tmax_abs <dbl>
```{r}

```
